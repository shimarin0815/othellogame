<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ  | Single-File SPA (All-in-One)</title>
  <style>
    /* ============ Theme & Reset ============ */
    :root {
      --bg: radial-gradient(1200px 800px at 10% 10%, #1d263b 0%, #0e1320 60%, #0a0f1a 100%);
      --panel: rgba(255, 255, 255, 0.06);
      --panel-strong: rgba(255, 255, 255, 0.12);
      --border: rgba(255, 255, 255, 0.2);
      --text: #eef2ff;
      --muted: #a6b3d0;
      --accent: #64f4ac;
      --accent-2: #2ee59d;
      --danger: #ff7b7b;
      --warn: #ffde59;
      --board-green: #17472a; /* modern deep green */
      --board-line: rgba(255, 255, 255, 0.08);
      --black: #141414;
      --white: #f5f7fa;
      --shadow-1: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 16px;
    }
    [data-theme="light"]{
      --bg: radial-gradient(1200px 800px at 10% 10%, #e6f0ff 0%, #f4f7fb 60%, #f8fbff 100%);
      --panel: rgba(0,0,0,0.04);
      --panel-strong: rgba(0,0,0,0.08);
      --border: rgba(0,0,0,0.12);
      --text: #0b1220;
      --muted: #536079;
      --accent: #2b9e74;
      --accent-2: #1f7e5c;
      --board-green: #1a7c45;
      --board-line: rgba(0,0,0,0.08);
      --black: #171717;
      --white: #fafafa;
    }

    /* ===== Skins (1) ===== */
    body[data-skin="matcha"]{ --accent:#2bb673; --accent-2:#1e8a57; --board-green:#1e6a3f; }
    body[data-skin="neon"]  { --accent:#7df9ff; --accent-2:#39ff14; --board-green:#0e3b26; }
    body[data-skin="pastel"]{ --accent:#ffd1dc; --accent-2:#c3f0ca; --board-green:#2c6e49; }

    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic UI", "Meiryo", sans-serif;
      color: var(--text);
      background: var(--bg);
      letter-spacing: .01em;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    button, input { font: inherit; }

    /* ============ Layout ============ */
    .wrap { min-height: 100dvh; display: grid; grid-template-rows: auto 1fr auto; }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 16px clamp(16px, 4vw, 28px); }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo { width: 36px; height: 36px; border-radius: 50%; background:
        radial-gradient(12px 12px at 12px 12px, var(--white), transparent 55%),
        radial-gradient(12px 12px at 24px 24px, var(--black), transparent 55%),
        linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow: 0 6px 18px rgba(0,0,0,.25), inset 0 0 0 2px var(--panel-strong); }
    .title { font-weight: 800; font-size: clamp(18px, 2.3vw, 22px); letter-spacing: .02em; }

    .toolbar { display: flex; gap: 8px; align-items: center; background: var(--panel); padding: 8px; border-radius: 999px; border: 1px solid var(--border); backdrop-filter: blur(8px); box-shadow: var(--shadow-1); }
    .pill { border-radius: 999px; padding: 8px 14px; border: 1px solid var(--border); background: var(--panel-strong); color: var(--text); cursor: pointer; }
    .pill:hover { filter: brightness(1.1); }

    main { display: grid; grid-template-columns: 1fr minmax(280px, 360px); gap: clamp(16px, 3vw, 32px); padding: 12px clamp(16px, 4vw, 28px) 28px; }
    @media (max-width: 880px){ main { grid-template-columns: 1fr; } .side { order: 2; } }

    /* ============ Board ============ */
    .board-wrap { display: grid; place-items: center; }
    .board { width: min(92vmin, 640px); aspect-ratio: 1 / 1; background: linear-gradient(180deg, #0f301c, var(--board-green)); border-radius: 20px; padding: 10px; box-shadow: 0 10px 40px rgba(0,0,0,.45), inset 0 0 0 2px #0b2215; position: relative; }
    .grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); gap: 3px; width: 100%; height: 100%; border-radius: 14px; background: var(--board-line); padding: 3px; }
    .cell { position: relative; background: #0b2a18; border-radius: 8px; border: 1px solid rgba(0,0,0,.25); outline: none; cursor: pointer; display: grid; place-items: center; transition: transform .06s ease; }
    .cell:hover { transform: translateY(-1px); }
    .cell[aria-disabled="true"] { cursor: default; }

    /* (2) Ripple effect */
    .ripple{ position:absolute; inset:0; pointer-events:none; }
    .ripple::after{ content:""; position:absolute; left:50%; top:50%; width:6px; height:6px; border-radius:999px; border:2px solid rgba(255,255,255,.35); transform: translate(-50%,-50%) scale(1); animation: ripple .6s ease-out; }
    @keyframes ripple{ to{ opacity:0; transform: translate(-50%,-50%) scale(18);} }

    .hint { width: 30%; aspect-ratio: 1/1; border-radius: 999px; border: 2px dashed rgba(255,255,255,.25); box-shadow: inset 0 0 16px rgba(255,255,255,.2); filter: drop-shadow(0 2px 6px rgba(0,0,0,.5)); display: none; transition: border-color .2s; }
    .cell.valid .hint { display: block; }
    .cell.valid:hover .hint { border-color: var(--accent); }
    .cell.valid .move-score { position: absolute; bottom: 8px; right: 8px; font-size: 12px; color: rgba(255,255,255,.8); }

    .disc { width: 78%; aspect-ratio: 1/1; border-radius: 999px; box-shadow: inset 0 12px 24px rgba(255,255,255,.15), inset 0 -6px 16px rgba(0,0,0,.45), 0 10px 20px rgba(0,0,0,.35); transform: translateZ(0); transition: transform .2s ease, background-color .25s ease; }
    .disc.black { background: radial-gradient(24px 24px at 30% 30%, #333, #000); border: 2px solid rgba(255,255,255,.05); }
    .disc.white { background: radial-gradient(24px 24px at 30% 30%, #fff, #cfd8ea); border: 2px solid rgba(0,0,0,.08); }

    .flipFX { animation: flipFX .35s ease; }
    @keyframes flipFX { 0% { transform: scale(.88) rotateY(0deg); } 50%{ transform: scale(.92) rotateY(90deg); } 100%{ transform: scale(1) rotateY(0deg); } }

    /* (5) Ghost preview */
    .ghost { width:78%; aspect-ratio:1/1; border-radius:999px; opacity:.35; box-shadow: inset 0 8px 16px rgba(255,255,255,.15); pointer-events:none; }
    .ghost.black{ background: radial-gradient(20px 20px at 30% 30%, #333, #000); }
    .ghost.white{ background: radial-gradient(20px 20px at 30% 30%, #fff, #cfd8ea); }

    /* (6) Heatmap via data-flips */
    .cell.valid[data-flips="1"] .hint{ border-color:#7db6ff; }
    .cell.valid[data-flips="2"] .hint{ border-color:#6df4b0; }
    .cell.valid[data-flips="3"] .hint{ border-color:#a5f06b; }
    .cell.valid[data-flips="4"] .hint{ border-color:#ffd166; }
    .cell.valid[data-flips="5"] .hint,
    .cell.valid[data-flips="6"] .hint{ border-color:#ff9f59; }
    .cell.valid[data-flips="7"] .hint,
    .cell.valid[data-flips="8"] .hint,
    .cell.valid[data-flips="9"] .hint,
    .cell.valid[data-flips="10"] .hint{ border-color:#ff7b7b; }

    /* ============ Sidebar / Panels ============ */
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; backdrop-filter: blur(10px); box-shadow: var(--shadow-1); }
    .side { display: grid; gap: 16px; align-content: start; }

    .status { display: grid; gap: 10px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }

    .turn { display: inline-grid; grid-auto-flow: column; align-items: center; gap: 10px; background: var(--panel-strong); padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border); }
    .dot { width: 14px; height: 14px; border-radius: 999px; display: inline-block; border: 2px solid rgba(0,0,0,.25); }
    .dot.black { background: #0d0d0d; }
    .dot.white { background: #fff; border-color: rgba(0,0,0,.15); }

    .score { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .score .card { background: var(--panel-strong); border: 1px solid var(--border); border-radius: 12px; padding: 12px; display: grid; gap: 6px; text-align: center; }
    .score .num { font-size: 28px; font-weight: 800; }

    .controls { display: grid; gap: 8px; }
    .btn { padding: 12px 14px; border-radius: 12px; border: 1px solid var(--border); color: var(--text); background: linear-gradient(180deg, var(--panel-strong), transparent); cursor: pointer; box-shadow: var(--shadow-1); display: grid; grid-auto-flow: column; place-content: center; place-items: center; gap: 8px; transition: transform .06s ease, filter .2s ease; }
    .btn:hover { filter: brightness(1.1); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: linear-gradient(180deg, var(--accent), var(--accent-2)); color: #062214; border-color: transparent; font-weight: 800; }
    .btn.warn { background: linear-gradient(180deg, #ffd166, #ffb703); color: #442a00; border-color: transparent; font-weight: 700; }

    .notice { font-size: 14px; color: var(--muted); min-height: 20px; }

    footer { padding: 10px 20px; color: var(--muted); text-align: center; font-size: 12px; }
    a { color: var(--accent); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="title">ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ </div>
      </div>
      <div class="toolbar" role="group" aria-label="ãƒ„ãƒ¼ãƒ«ãƒãƒ¼">
        <button id="skinBtn" class="pill" aria-label="ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆåˆ‡æ›¿">ğŸ¨ ãƒ†ãƒ¼ãƒ</button>
        <button id="themeToggle" class="pill" aria-label="ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ (ãƒ©ã‚¤ãƒˆ/ãƒ€ãƒ¼ã‚¯)">ğŸŒ™/â˜€ï¸</button>
        <button id="helpBtn" class="pill" aria-label="éŠã³æ–¹">â“ éŠã³æ–¹</button>
      </div>
    </header>

    <main>
      <section class="board-wrap">
        <div class="board panel" role="region" aria-label="ã‚ªã‚»ãƒ­ç›¤">
          <div id="grid" class="grid" role="grid" aria-label="8x8 ãƒã‚¹ã®ã‚ªã‚»ãƒ­ç›¤"></div>
        </div>
      </section>

      <aside class="side">
        <section class="panel status" aria-live="polite">
          <div class="row">
            <div class="turn">
              <span>æ‰‹ç•ªï¼š</span>
              <span id="turnDot" class="dot black" aria-hidden="true"></span>
              <strong id="turnText">é»’</strong>
            </div>
            <div class="turn" title="1æ‰‹ã®åˆ¶é™æ™‚é–“">
              â± <strong id="tleft">30</strong>s
            </div>
            <label style="display:inline-grid; gap:6px; align-items:center; grid-auto-flow:column;">
              <input type="checkbox" id="hintToggle" checked /> ãƒ’ãƒ³ãƒˆè¡¨ç¤º
            </label>
          </div>
          <div class="score">
            <div class="card" aria-label="é»’ã®ã‚¹ã‚³ã‚¢">
              <div>é»’</div>
              <div id="scoreBlack" class="num">2</div>
            </div>
            <div class="card" aria-label="ç™½ã®ã‚¹ã‚³ã‚¢">
              <div>ç™½</div>
              <div id="scoreWhite" class="num">2</div>
            </div>
          </div>
          <div id="notice" class="notice"></div>
        </section>

        <section class="panel controls">
          <button class="btn primary" id="newGame">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
          <div class="row">
            <button class="btn" id="undo">â¬…ï¸ 1æ‰‹æˆ»ã™</button>
            <button class="btn" id="redo">â¡ï¸ ã‚„ã‚Šç›´ã—</button>
          </div>
          <button class="btn warn" id="reset">åˆæœŸé…ç½®ã«ãƒªã‚»ãƒƒãƒˆ</button>
          <div class="row">
            <label style="display:inline-grid; gap:6px; grid-auto-flow:column; align-items:center;">
              <input type="checkbox" id="cpuWhite" /> CPUï¼ˆç™½ã‚’è‡ªå‹•ï¼‰
            </label>
            <button class="btn" id="shareBtn">ğŸ“£ çµæœã‚’ã‚³ãƒ”ãƒ¼</button>
          </div>
          <details class="panel" style="padding:10px;">
            <summary>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ</summary>
            <ul style="margin:.5em 0 .2em 1.2em; line-height:1.7;">
              <li>çŸ¢å°ã‚­ãƒ¼ï¼šé¸æŠãƒã‚¹ã‚’ç§»å‹•</li>
              <li>Enter / Spaceï¼šçŸ³ã‚’ç½®ã</li>
              <li>Uï¼š1æ‰‹æˆ»ã™ã€Rï¼šã‚„ã‚Šç›´ã—ã€Nï¼šæ–°ã—ã„ã‚²ãƒ¼ãƒ </li>
            </ul>
          </details>
        </section>

        <section class="panel" style="font-size:14px; line-height:1.7;">
          <strong>ç›®çš„ï¼š</strong> æ¥½ã—ãéŠã³ãªãŒã‚‰ã€å…ˆã‚’èª­ã‚€åŠ›ãƒ»è¦³å¯ŸåŠ›ãƒ»åˆ¤æ–­åŠ›ã‚’é›ãˆã‚‹ã“ã¨ã€‚
          <br />
          <strong>ä¸»ãªæ©Ÿèƒ½ï¼š</strong> 2äººå¯¾æˆ¦ï¼ç½®ã‘ã‚‹å ´æ‰€ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‹å¼·ã•è‰²ï¼ã‚´ãƒ¼ã‚¹ãƒˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼è‡ªå‹•ãƒ‘ã‚¹ï¼ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼Undo & Redoï¼ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ãƒ†ãƒ¼ãƒï¼†ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆåˆ‡æ›¿ï¼åŠ¹æœéŸ³ï¼†æŒ¯å‹•ï¼ã‚¿ãƒ¼ãƒ³ã‚¿ã‚¤ãƒãƒ¼ï¼CPUï¼ˆç™½ï¼‰ï¼çµæœã‚³ãƒ”ãƒ¼ï¼è‡ªå‹•ä¿å­˜ã€‚
        </section>
      </aside>
    </main>

    <footer>
      Â© <span id="year"></span> Othello SPA Â· ã‚·ãƒ³ã‚°ãƒ«ãƒ•ã‚¡ã‚¤ãƒ« / ãƒ¢ãƒ€ãƒ³UI
    </footer>
  </div>

  <dialog id="howto">
    <form method="dialog" class="panel" style="max-width:720px;">
      <h3 style="margin-top:0">éŠã³æ–¹</h3>
      <p>é»’ãŒå…ˆæ‰‹ã§ã™ã€‚ç›¸æ‰‹ã®çŸ³ã‚’ã¯ã•ã‚€ã‚ˆã†ã«ç½®ãã¨ã€ãã®é–“ã®çŸ³ãŒè‡ªåˆ†ã®è‰²ã«ã²ã£ãã‚Šè¿”ã‚Šã¾ã™ã€‚ç½®ã‘ã‚‹å ´æ‰€ã¯è–„ã„ä¸¸ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã©ã¡ã‚‰ã‚‚ç½®ã‘ãªããªã£ãŸã‚‰ã‚²ãƒ¼ãƒ çµ‚äº†ã€çŸ³ã®å¤šã„æ–¹ãŒå‹ã¡ï¼</p>
      <p>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚‚æ“ä½œã§ãã¾ã™ï¼ˆçŸ¢å°ã‚­ãƒ¼ï¼‹Enterï¼‰ã€‚</p>
      <div style="display:flex; justify-content:flex-end;">
        <button class="btn" value="ok">OK</button>
      </div>
    </form>
  </dialog>

  <script>
    "use strict";
    // ====== Constants & State ======
    const SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;
    const DIRS = [ [-1,-1],[-1,0],[-1,1], [0,-1], [0,1], [1,-1],[1,0],[1,1] ];

    // (9) Turn timer
    const TURN_SECONDS = 30;
    let timerId = null, remain = TURN_SECONDS;

    // Global state
    let board = makeEmptyBoard();
    let current = BLACK; // black starts
    let history = []; // stack of {board, current}
    let redoStack = [];
    let showHints = true;
    let skinIdx = 0;

    // ====== DOM ======
    const gridEl = document.getElementById('grid');
    const turnDot = document.getElementById('turnDot');
    const turnText = document.getElementById('turnText');
    const scoreBlack = document.getElementById('scoreBlack');
    const scoreWhite = document.getElementById('scoreWhite');
    const notice = document.getElementById('notice');
    const hintToggle = document.getElementById('hintToggle');
    const newGameBtn = document.getElementById('newGame');
    const resetBtn = document.getElementById('reset');
    const undoBtn = document.getElementById('undo');
    const redoBtn = document.getElementById('redo');
    const themeToggle = document.getElementById('themeToggle');
    const helpBtn = document.getElementById('helpBtn');
    const howto = document.getElementById('howto');
    const skinBtn = document.getElementById('skinBtn');
    const cpuWhiteChk = document.getElementById('cpuWhite');
    const tleftEl = document.getElementById('tleft');

    document.getElementById('year').textContent = new Date().getFullYear();

    // ====== Helpers ======
    function makeEmptyBoard(){ return Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY)); }
    function cloneBoard(b){ return b.map(row => row.slice()); }
    function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }
    function opponent(p){ return -p; }
    function colorName(p){ return p === BLACK ? 'é»’' : 'ç™½'; }

    // Find flips if player p places at (r,c). Return array of [r,c] to flip.
    function getFlipsForMove(b, r, c, p){
      if (!inBounds(r,c) || b[r][c] !== EMPTY) return [];
      let flips = [];
      for (const [dr,dc] of DIRS){
        let rr = r + dr, cc = c + dc;
        let line = [];
        if (!inBounds(rr,cc) || b[rr][cc] !== opponent(p)) continue; // need at least one opponent first
        while(inBounds(rr,cc) && b[rr][cc] === opponent(p)){
          line.push([rr,cc]); rr += dr; cc += dc;
        }
        if (inBounds(rr,cc) && b[rr][cc] === p && line.length){ flips.push(...line); }
      }
      return flips;
    }

    function getValidMoves(b, p){
      const map = new Map();
      for (let r=0; r<SIZE; r++){
        for (let c=0; c<SIZE; c++){
          if (b[r][c] !== EMPTY) continue;
          const flips = getFlipsForMove(b, r, c, p);
          if (flips.length) map.set(`${r},${c}`, flips);
        }
      }
      return map;
    }

    function score(b){
      let black=0, white=0;
      for (let r=0; r<SIZE; r++) for(let c=0;c<SIZE;c++){
        if (b[r][c]===BLACK) black++; else if (b[r][c]===WHITE) white++;
      }
      return {black, white};
    }

    function pushHistory(){ history.push({ board: cloneBoard(board), current }); }

    // ====== SFX (4) ======
    function sfx(freq=440, dur=0.06, type="sine", vol=0.03){
      try{
        const ctx = sfx.ctx ||= new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = vol; o.connect(g).connect(ctx.destination);
        o.start(); o.stop(ctx.currentTime + dur);
      }catch(e){ /* audio blocked â†’ ignore */ }
    }

    // ====== UI Rendering ======
    function buildGrid(){
      gridEl.innerHTML = '';
      for (let r=0; r<SIZE; r++){
        for (let c=0; c<SIZE; c++){
          const cell = document.createElement('button');
          cell.className = 'cell'; cell.setAttribute('role', 'gridcell');
          cell.dataset.r = r; cell.dataset.c = c;
          cell.addEventListener('click', onCellClick);
          cell.addEventListener('keydown', onCellKey);
          // (5) Ghost preview events
          cell.addEventListener('mouseenter', ()=> showGhost(r,c));
          cell.addEventListener('mouseleave', hideGhost);
          const hint = document.createElement('div'); hint.className = 'hint'; cell.appendChild(hint);
          const ms = document.createElement('div'); ms.className = 'move-score'; ms.hidden = true; cell.appendChild(ms);
          gridEl.appendChild(cell);
        }
      }
    }

    function renderBoard(options={}){
      const {flashFlips=[]} = options;
      const valids = getValidMoves(board, current);
      for (const cell of gridEl.children){
        const r = +cell.dataset.r, c = +cell.dataset.c;
        // Clear dynamic children
        cell.innerHTML = '';
        const hint = document.createElement('div'); hint.className = 'hint'; cell.appendChild(hint);
        const ms = document.createElement('div'); ms.className = 'move-score'; ms.hidden = true; cell.appendChild(ms);

        const vkey = `${r},${c}`;
        if (board[r][c] !== EMPTY){
          const d = document.createElement('div');
          d.className = 'disc ' + (board[r][c]===BLACK ? 'black' : 'white');
          if (flashFlips.some(([rr,cc]) => rr===r && cc===c)) d.classList.add('flipFX');
          cell.appendChild(d);
          cell.setAttribute('aria-disabled','true'); cell.tabIndex = -1; cell.classList.remove('valid');
          cell.setAttribute('aria-label', `${r+1}è¡Œ${c+1}åˆ—ï¼š${board[r][c]===BLACK?'é»’':'ç™½'}`);
        } else if (valids.has(vkey)){
          cell.classList.add('valid');
          if (showHints){
            const flips = valids.get(vkey);
            ms.hidden = false; ms.textContent = flips.length; cell.dataset.flips = String(Math.min(10, flips.length));
          } else { cell.removeAttribute('data-flips'); }
          cell.tabIndex = 0; cell.removeAttribute('aria-disabled');
          cell.setAttribute('aria-label', `${r+1}è¡Œ${c+1}åˆ—ï¼šç½®ã‘ã¾ã™ï¼ˆ${colorName(current)}ï¼‰`);
        } else {
          cell.tabIndex = -1; cell.setAttribute('aria-disabled','true'); cell.classList.remove('valid'); cell.removeAttribute('data-flips');
          cell.setAttribute('aria-label', `${r+1}è¡Œ${c+1}åˆ—ï¼šç½®ã‘ã¾ã›ã‚“`);
        }
      }

      // Status
      const s = score(board);
      scoreBlack.textContent = s.black; scoreWhite.textContent = s.white;
      turnText.textContent = colorName(current);
      turnDot.className = 'dot ' + (current===BLACK?'black':'white');

      // Save
      saveState();

      // (8) CPU move if enabled
      maybeCpuTurn();

      // (9) Reset/start timer each (re)render of a human's turn
      startTurnTimer(TURN_SECONDS);
    }

    // ====== Ghost preview (5) ======
    function showGhost(r,c){
      const valids = getValidMoves(board, current);
      const key = `${r},${c}`; if (!valids.has(key)) return;
      const flips = valids.get(key);
      for (const [fr,fc] of flips){
        const target = [...gridEl.children].find(el=>+el.dataset.r===fr && +el.dataset.c===fc);
        if (!target) continue; const g = document.createElement('div');
        g.className = 'ghost ' + (current===BLACK? 'black':'white'); target.appendChild(g);
      }
      // preview on hovered cell itself
      const self = [...gridEl.children].find(el=>+el.dataset.r===r && +el.dataset.c===c);
      if (self){ const gp = document.createElement('div'); gp.className = 'ghost ' + (current===BLACK? 'black':'white'); self.appendChild(gp); }
    }
    function hideGhost(){ document.querySelectorAll('.ghost').forEach(n=>n.remove()); }

    // ====== Game Flow ======
    function setupInitial(){
      board = makeEmptyBoard();
      const m = SIZE/2; // 4
      board[m-1][m-1] = WHITE; board[m-1][m] = BLACK; board[m][m-1] = BLACK; board[m][m] = WHITE;
      current = BLACK; history = []; redoStack = []; notice.textContent = '';
      renderBoard();
    }

    function onCellClick(e){ const cell = e.currentTarget; tryPlace(+cell.dataset.r, +cell.dataset.c); }

    function onCellKey(e){
      const cell = e.currentTarget; const r = +cell.dataset.r, c = +cell.dataset.c;
      if (['Enter',' '].includes(e.key)){ e.preventDefault(); tryPlace(r,c); return; }
      let nr=r, nc=c; // Arrow navigation
      if (e.key==='ArrowUp') nr = Math.max(0, r-1);
      else if (e.key==='ArrowDown') nr = Math.min(SIZE-1, r+1);
      else if (e.key==='ArrowLeft') nc = Math.max(0, c-1);
      else if (e.key==='ArrowRight') nc = Math.min(SIZE-1, c+1);
      else if (e.key==='u' || e.key==='U'){ undo(); return; }
      else if (e.key==='r' || e.key==='R'){ redo(); return; }
      else if (e.key==='n' || e.key==='N'){ newGame(); return; }
      const next = [...gridEl.children].find(el => +el.dataset.r===nr && +el.dataset.c===nc);
      if (next) next.focus();
    }

    function tryPlace(r,c,opts={}){
      // If CPU's turn, ignore user clicks (but allow internal CPU moves)
const { byCpu = false } = opts;
if (current===WHITE && cpuWhiteChk.checked && !byCpu) return;
      const valids = getValidMoves(board, current); const key = `${r},${c}`; if (!valids.has(key)) return;

      pushHistory(); redoStack = [];

      const cell = [...gridEl.children].find(el=>+el.dataset.r===r && +el.dataset.c===c);
      const rip = document.createElement('div'); rip.className='ripple'; cell.appendChild(rip); setTimeout(()=>rip.remove(), 600);

      const flips = valids.get(key);
      board[r][c] = current;
      for (const [fr,fc] of flips){ board[fr][fc] = current; }
      if (navigator.vibrate) navigator.vibrate(40); // (3)
      sfx(520, .05, 'triangle', .035); // (4)

      renderBoard({ flashFlips: [[r,c], ...flips] });

      const nextP = opponent(current);
      const oppMoves = getValidMoves(board, nextP);
      if (oppMoves.size === 0){
        const myMoves = getValidMoves(board, current);
        if (myMoves.size === 0){ endGame(); return; }
        else { notice.textContent = `${colorName(nextP)}ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ãŸã‚ãƒ‘ã‚¹ã€‚${colorName(current)}ã®ã¾ã¾ã§ã™ã€‚`; renderBoard(); return; }
      } else {
        current = nextP; notice.textContent = '';
        renderBoard();
      }
    }

    function endGame(){
      stopTurnTimer();
      const s = score(board);
      let msg = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼šé»’ ${s.black} - ${s.white} ç™½ã€‚`;
      if (s.black > s.white) msg += ' å‹è€…ã¯ã€Œé»’ã€ï¼';
      else if (s.white > s.black) msg += ' å‹è€…ã¯ã€Œç™½ã€ï¼';
      else msg += ' å¼•ãåˆ†ã‘ï¼';
      notice.textContent = msg; confettiEmoji(); // (7)
      for (const cell of gridEl.children){ cell.tabIndex = -1; cell.setAttribute('aria-disabled','true'); cell.classList.remove('valid'); }
    }

    // ====== Actions ======
    function newGame(){ setupInitial(); }
    function reset(){ pushHistory(); redoStack = []; setupInitial(); }
    function undo(){ if (!history.length) return; redoStack.push({ board: cloneBoard(board), current }); const prev = history.pop(); board = cloneBoard(prev.board); current = prev.current; notice.textContent = '1æ‰‹æˆ»ã—ã¾ã—ãŸã€‚'; renderBoard(); }
    function redo(){ if (!redoStack.length) return; history.push({ board: cloneBoard(board), current }); const next = redoStack.pop(); board = cloneBoard(next.board); current = next.current; notice.textContent = 'ã‚„ã‚Šç›´ã—ã¾ã—ãŸã€‚'; renderBoard(); }

    // ====== CPU (8) ======
    function bestMoveGreedy(b, p){
      const valids = getValidMoves(b, p); if (!valids.size) return null;
      let best=null, bestScore=-1; for (const [key, flips] of valids.entries()){ if (flips.length > bestScore){ bestScore = flips.length; best = key; } }
      return best; // "r,c"
    }
    function maybeCpuTurn(){
      if (!cpuWhiteChk.checked) return; if (current !== WHITE) return; // only CPU for white
      const m = bestMoveGreedy(board, WHITE);
      if (!m){ notice.textContent = 'CPUã¯ç½®ã‘ã‚‹å ´æ‰€ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ‘ã‚¹ï¼‰'; // current stays if human has move
        const humanMoves = getValidMoves(board, BLACK); if (!humanMoves.size){ endGame(); } return; }
      stopTurnTimer(); // CPU acts immediately, no timer countdown for CPU
      setTimeout(()=> { const [r,c] = m.split(',').map(Number); tryPlace(r,c,{byCpu:true}); }, 350);
    }

    // ====== Turn Timer (9) ======
    function startTurnTimer(sec=TURN_SECONDS){
      stopTurnTimer(); remain = sec; tleftEl.textContent = remain;
      // only for human turns (if CPU white and it's white's turn â†’ no timer)
      if (current===WHITE && cpuWhiteChk.checked) { tleftEl.textContent = 'CPU'; return; }
      timerId = setInterval(()=>{
        tleftEl.textContent = --remain;
        if (remain <= 0){
          stopTurnTimer(); // pass turn on timeout
          notice.textContent = 'æ™‚é–“åˆ‡ã‚Œã€ãƒ‘ã‚¹ï¼';
          const myMoves = getValidMoves(board, current);
          if (myMoves.size){ current = opponent(current); renderBoard(); }
          else { // no moves even if time up
            const oppMoves = getValidMoves(board, opponent(current));
            if (!oppMoves.size) endGame(); else { current = opponent(current); renderBoard(); }
          }
        }
      }, 1000);
    }
    function stopTurnTimer(){ clearInterval(timerId); timerId = null; }

    // ====== Persistence & Theme & Skin (1) ======
    const SAVE_KEY = 'othello_spa_state_v2';
    function saveState(){
      try{
        const data = { board, current, showHints, theme: document.body.hasAttribute('data-theme') ? 'light' : 'dark', skin: document.body.dataset.skin||'default', cpuWhite: !!cpuWhiteChk.checked };
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      }catch(e){ /* ignore */ }
    }
    function loadState(){
      try{
        const raw = localStorage.getItem(SAVE_KEY); if (!raw) return false;
        const data = JSON.parse(raw); if (!Array.isArray(data.board)) return false;
        board = data.board; current = data.current ?? BLACK; showHints = !!data.showHints;
        hintToggle.checked = showHints;
        if (data.theme==='light') document.body.setAttribute('data-theme','light'); else document.body.removeAttribute('data-theme');
        if (data.skin && data.skin!=='default') document.body.dataset.skin = data.skin;
        cpuWhiteChk.checked = !!data.cpuWhite;
        renderBoard(); return true;
      }catch(e){ return false; }
    }

    function applyThemeFromStorage(){ const t = localStorage.getItem('theme') || 'dark'; if (t==='light') document.body.setAttribute('data-theme','light'); else document.body.removeAttribute('data-theme'); }

    // ====== Share (10) ======
    function copyResult(){ const s = score(board); const msg = `ã€ã‚ªã‚»ãƒ­çµæœã€‘é»’:${s.black} ç™½:${s.white}ï½œ#Othello #WebGame`; navigator.clipboard?.writeText(msg); notice.textContent = 'çµæœãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼'; }

    // ====== Confetti (7) ======
    function confettiEmoji(count=40){ const area = document.body; for(let i=0;i<count;i++){ const s = document.createElement('div'); s.textContent = ["ğŸ‰","âœ¨","ğŸŠ","ğŸ’«"][i%4]; s.style.cssText = `position:fixed; left:${Math.random()*100}vw; top:-10vh; font-size:${12+Math.random()*24}px; transform:translateY(0); transition:transform ${1+Math.random()*1.6}s linear; z-index:9999`; area.appendChild(s); requestAnimationFrame(()=> s.style.transform = `translateY(${120+Math.random()*80}vh) rotate(${Math.random()*360}deg)`); setTimeout(()=>s.remove(), 2200);} }

    // ====== Events ======
    hintToggle.addEventListener('change', () => { showHints = hintToggle.checked; renderBoard(); });
    newGameBtn.addEventListener('click', newGame);
    resetBtn.addEventListener('click', reset);
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    themeToggle.addEventListener('click', () => {
      const isLight = document.body.hasAttribute('data-theme'); if (isLight) document.body.removeAttribute('data-theme'); else document.body.setAttribute('data-theme','light'); localStorage.setItem('theme', document.body.hasAttribute('data-theme') ? 'light' : 'dark');
      saveState();
    });
    helpBtn.addEventListener('click', () => howto.showModal());
    skinBtn.addEventListener('click', ()=>{
      const skins = ['default','matcha','neon','pastel'];
      const cur = document.body.dataset.skin || 'default';
      const idx = skins.indexOf(cur); const next = skins[(idx+1)%skins.length];
      if (next==='default') delete document.body.dataset.skin; else document.body.dataset.skin = next; saveState();
      notice.textContent = `ãƒ†ãƒ¼ãƒï¼š${next}`;
    });
    cpuWhiteChk.addEventListener('change', ()=>{ saveState(); renderBoard(); });
    document.getElementById('shareBtn').addEventListener('click', copyResult);

    // ====== Init ======
    applyThemeFromStorage();
    buildGrid();
    if (!loadState()) setupInitial(); else startTurnTimer(TURN_SECONDS);
  </script>
</body>
</html>
